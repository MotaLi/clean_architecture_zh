# 第十三章 组件耦合
下面介绍的三个原则是要解决组件间的关系。这里我们又要考虑开发效率和逻辑设计的权衡。冲击构件结构的力量是技术性的，政策性的和不稳定性的。

## 无环依赖原则
> 组件依赖图遵守无环的设计

你是否有过工作了一整天，使得你写的东西跑起来了，然后回家，再第二天早上发现你写的东西不再能正常跑起来了？为什么？因为有些人比你工作的晚，改了你东西的依赖，我称作这种情况为“早晨综合征”。

“早晨综合征”发生在许多开发者可能修改了同样的源文件的开发模式。对于规模小，人数少的项目，这不是大问题。但项目数量一多，开发团队变多，“早晨综合征”真的就是噩梦了。几周都没有团队可能构建一个稳定的项目版本是非常罕见的。每个人都保有变更，并努力使得这些变更最终能和其他人的变更融合，能使系统跑起来。

过去这十年，有两个解决办法都是从通讯行业演变过来。第一个叫“每周构建”，第二个叫无环依赖原则（ADP）。

### 每周构建
每周构建常常用于中等规模的项目。所有的开发者在一周的前四天或略其他开发者的提交，所有开发者都在自己的代码副本里工作，不用考虑和其他人的工作集成。然后到了周五，把所有人的更变集成，再构建系统。

这方法很棒的是允许开发者在前四天独立地工作，缺点很明显，周五的集成非常的痛苦。

不幸的是，随着项目的增长，想要在周五完成项目的集成越来越不现实。集成的时间可能还要延伸到周六，有了周六这样的经历，足够让开发者觉得集成应该成周三就开始，这样开始集成的时间就慢慢移动到了一周的中间。

随着开发时间的占比对于集成时间逐渐下降，团队的开发效率也下降。最后的结果可想而知，开发者和项目管理者，可能宣布将集成时间改为两周一次，这足以能维持一段时间，但是集成时间随着项目规模也将增长。

最后，这种情况将导致灾难。为了维持效率，构建周期继续变长，但变长的构建周期将怎加项目的风险。集成和测试也将更难做，团队丢失了快速回馈的优势。

### 消除依赖循环

这个方法是分割开发环境为数个可发布组件。这些组件是数个工作单元，每个工作单元有单个开发者或单个团队负责。当开发者们将一个组件完成，他们可以发布这个组件供其他开发者使用。他们给这个发布组件一个发布号，把它放进某个目录下供娶她团队使用。这样这些开发者可以继续在自己的私有区域继续修改他们的组件。每个人只要用以发布的版本即可。

随着一个个新发布组件的可用，其他团队可以决定是否要马上切换到新的发布版本。如果决定不切换，继续用老版本即可。一旦他们时机成熟，那么就开始用新发布版本。

因此不会有团队受到于其他团队的影响，对一个组件的改变不必对其他团队有直接影响。每个团队能自行决定何时调整自己的组件兼容新版本。此外，集成只是小幅增加，所有开发者不必都聚在同一个时间点去集成他们所做的事情。

这是非常简单和理性的过程，也被广泛使用。为了使之更好运作，你必须管理组件依赖结构，不可以有循环依赖。如果在依赖结构中有循环依赖，那就不能避免“早晨综合症”。

考虑图14.1的组件图。它展示了组合到应用里的相当典型的组件结构。对于这个样例，我们忽略掉应用的功能。重点来看组件的依赖结构。注意到这个结构是有向图。每个组件都是结点，依赖关系是有向线段。

注意一件事：不管从哪个组件开始，不可能沿着依赖关系由绕回起始地组件。这结构就是无环的。叫做有向无环图（DAG）。

现在考虑当Presenters组件的负责团队发布了新版本会发生什么？我们很容易找到受这个新版本影响的组件！你只要沿着依赖关系相反的指向。因此View和Main组件都收到影响。这两个组件的开发者们都将决定何时应该去集成新发布的Presenters。

再注意到Main新发布时，不会对系统的其他组件有影响。其他组件并不知道Main，也不关心Main的变化，非常的现象。这意味着Main的新发布影响相对小。当Presenters的开发者们想对此跑单元测试，他们只要构建他们开发的Presenters版本和当前使用的Interactors和Entities组件的版本。不需要其他模块的参与，非常好的现象。这意味着Presenters的开发者只需要相对较少的工作就能搭建测试，要变量考虑的变量相当少。

当发布整个系统时，这个过程是自底向上的，首先对Entities进行编译，测试，发布。再做Database和Interactors组件的，随后就是Presenters，View，Controllers，Authorizer，最后是Main组件。这个过程很清晰，容易处理。因为我们知道系统各个部分的依赖关系所以才知道了如何构建系统。

### 组件依赖图中有循环依赖的影响

假设有新的需求迫使我们在Entities组件中用了Authorizer组件的类，比如Entities组件中的User类用了Authorizer组件中的Permissions类，依赖图如14.2所示。

这个循环造成了很直接的问题。比如，Database组件的开发者要发布了，它得兼容Entities，由于有这个循环依赖，Database组件现在也得兼容Authorizer，但Authorizer依赖于Interactors。这使得Database难于发布了。Entities，Authorizer，Interactors实际上形成了一个大组件了，在这之上开发的人员都会经历“早晨综合症”。他们将互相钳制因为他们都用到了其他组件相同的版本。

但这只是麻烦的一部分。考虑当我们想测试Entities组件会发生什么？我们得构建Authorizer和Interactors组件，太烦了。如果真这样的话，这些组件间的耦合水平太糟了。

你可能在想，包含了这么多不同的库，这门多其他人的东西，就只为了跑自己类的单元测试？如果你细心一点，你会发现关系图里存在循环依赖，这会使组件很难独立。单元测试和发布都变得困难又容易出错。此外，构建问题随着模块的数量呈几何增长。还有，当依赖图里有循环依赖是，很难计算出构建系统的顺序，事实上，可能都没有正确的构建顺序。在一些语言中也将导致一些棘手的问题，比如Java，可能导致从编译后的二进制文件读取声明。

### 解除循环依赖

解除组件的循环依赖，使之复原呈DAG的依赖图是有可能的。有两种主要的机制：

1. 应用依赖倒置原则（DIP），如图14.3中，我们创建了一个接口，接口中是User需要的方法。我们将接口放入Entities组件，接口的实现放入Authorizer组件，Entities和Authorizer的依赖就倒置了，进而解除了循环依赖。
2. 创建一个新组件，Entities和Authorizer都依赖这个新组件。把问题的类都移到这个新组件。

### 抖动

第二个方法：组件结构在需求变化中是不稳定的。确实，随着应用程序的增长，组件依赖结构也增长，并且抖动，因此，我们得实时注意依赖结构中循环依赖的产生。但它产生时，要及时去解除，有时这意味着创建新组件，使得依赖结构增长，更容易出现循环依赖。




## 自上而下设计











## 稳定依赖原则









## 稳定抽象原则












## 小结



