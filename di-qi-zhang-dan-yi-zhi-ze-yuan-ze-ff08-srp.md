# 第七章 单一职责原则（SRP）

在接下来的所有原则（SOLID）中，单一职责原则可能是比较难懂的，这很可能因为它的名字取得不准确，很容易让开发者从这个名字中认为它的含义是每个模块都只做一件事。

诚然，单一职责原则有点像类似的含义，一个函数有且只做一件事。我们用单一职责原则去重构一个繁杂庞大的函数成更小的函数，我们在最底的层面上使用它。但是，这并不是我们的SOLID原则中的单一职责原则！

传统上，单一职责原则是这么表述的：

> 一个模块有且只能由于一种原因被改变

软件系统发生改变是为了满足用户和利益相关者，这些用户和利益相关者是上述描述里“改变的原因”，那么，我们可以这么表述这项原则：

> 一个模块有且只能对其中之一负责，用户或者利益相关者

不幸的是，“用户”，“利益相关者”这些词在这里并不恰当，因为可能有多个用户想在一样的地方改变系统，利益相关者也是。然而，我们真的指代一个群体，要求修改的一个或更多的人，我们把这中群体称为角色。[^1]

最终，我们这么描述单一职责原则：

> 一个模块有且只能对一个角色负责

现在，这里的“模块”我们指的是什么呢？最简单的定义就是源文件，最简单的定义就是源文件，大多时候这个定义都说的通。但在一些语言和开发环境，并不是用源文件去装代码。这种情况下一个模块是一组内聚的函数和数据结构。

“内聚”（cohesive）这个词暗示这SRP。内聚是一种绑定代码在一起对单一角色负责的力量。

也是最好的理解这个原则的方式就是去举例违反它的症状。

## 症状一：意外的重复

我最新的例子是工资应用里的Employee这个类。它右三个方法：calculatePay\(\) , reportHours\(\) , 和  
save\(\) \(图7.1\)。

这个类违反了SRP是因为这三个方法是对三个十分不同的角色负责的。

* calculatePay\(\)方法描述了会计部门，他们对CFO报告。
* reportHours\(\)方法描述了人力资源部门，他们对COO报告
* save\(\)方法描述了数据库管理员（DBAs），他们对CTO报告

把这三个方法的源代码放在一个Employee类，开发者将使这三个角色相互耦合。这种耦合会造成CFO团队的动作将影响COO团队的所依赖的部分。

比如，设想calculatePay\(\)函数和reportHours\(\)函数公用了一个计算非工作日时间的公用算法。对于开发者并不希望出现重复代码，因此将这个算法封装成一个regularHours\(\)函数。

现在假设CFO团队决定将非工作日的时间计算进行调整，相反，人力资源部门的COO团队对非工作日时间有不同的应用，并不希望调整。











[^1]: Unfortunately, the words “user” and “stakeholder” aren’t really the right words to use here. There will likely be more than one user or stakeholder who wants the system changed in the same way. Instead, we’re really referring to a group—one or more people who require that change. We’ll refer to that group as an actor.

