# 第十一章 依赖倒置原则（DIP）

依赖倒置原则（DIP）告诉我们最灵活的系统应该是其中的源码依赖只指向抽象，而非具体实现。  
在静态类型语言，比如Java，用use，import，include语句时，应该只指向源模块，包括接口，抽象类，或其他的抽象声明。而绝不能依赖具体实现类。  
在动态语言中运用同样的规则，比如Ruby和Python，源码依赖不该指向具体实现模块。但是，在这类语言中，很难说清具体实现模块怎么定义。具体来说，这种模块就是其中包含了调用具体实现的函数。  
很明显，把这种想法当作规则很不现实，因为软件系统肯定得依赖大量得具体实现类库，比如，Java中得String时具体实现的，要把它改成抽象的话不太现实。不能，也不应该避免对具体实现的java.lang.string的源码依赖。  
相比较而言，String类非常文档，对这个类的改变非常少，而且可控。程序员和架构师不必单向String类频繁随意的改变。  
出于这些原因，我们在考虑DIP时，应该忽略稳定的依赖，比如操作系统，平台工具。我们接纳这些具体实现的依赖是因为我们得知道我们依赖得东西不会改变。

## 稳定的抽象

每个都抽象接口的改变都放映了对具体实现类的改变。反之，改变具体实现并不总是，或者非常少会要求他们实现的接口改变。因此接口比实现更加不易变。  
确实，好的软件设计者和架构师努力去减少接口的易变形，他们得尝试对于实现类增加函数而不改变接口。这是软件设计第一课。  
这意味着，稳定得软件架构避免依赖易变得具体类，倾向于使用稳定的抽象接口，可以总结为以下一组非常规范的代码实践：

* **别引用易变的具体实现类**。请引用抽象接口类。无论静态语言还是动态语言，这条规则都适用。这也给对象创建加了约束，进而迫使使用抽象工厂模式创建对象。
* **别从易变的具体实现类派生**。这条是上一条的推导，但这里特别提到。在静态语言中，继承是所有代码关系里最强，最死板的；因此，在使用时应该非常小心。在动态语言中，继承问题较少，但它仍然是个依赖--谨慎总是最明智的选择。
* **别覆盖具体实现的函数**。具体实现的函数常常要求源码依赖。但你覆盖这些函数时，你无法消除这些依赖，事实上，你继承了他们。为了管理这些依赖，这应该把这个函数声明成抽象的，然后可以写多个实现。
* **别提任何的具体实现和易变类的名字**。这只是DIP本身的要求。

## 工厂



