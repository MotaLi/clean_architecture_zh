# 第十三章 组件聚合
哪些类应该归属到哪些模块？这是很重要的决定，需要有良好的软件工程原则的指导。不幸的是，多年来，这一决定几乎完全基于上下文而以临时方式作出。

这一章，我们将探讨组件聚合的三个原则：
 - **REP**: The Reuse/Release Equivalence Principle
 - **CCP**: The Common Closure Principle
 - **CRP**: The Common Reuse Principle

## 复用/发布等效原则（REP）
> 细粒度的重用是细粒度的发布

近十年来出现了很多模块管理工具，如Maven，Leiningen和RVM。这些工具的兴起很重要的原因是因为在这段时间，超大数量的可重用组件或组件库的创建。我们现在是生活在软件重用的年代-实现了面向对象模型中最古老的一个承诺。

复用/发布等效原则（REP）至少字面上看起来很明显，人们想重用软件组件的话，这些组件应当有发布的历史记录，每个记录都有发布号。
简单地想是因为没有发布号，没法保证所有的可重用组件是相互兼容的，而且有发布号可以让软件开发者了解新的发布版本的到来及其带来的变化特性。
当开发者得到新版本的提示，基于新版本的变化考虑而继续使用旧版本，这并不罕见。因此，发布过程应当生成适当的通知和发布文档，以便用户可以决定是否使用和合适去集成新的发布版本。
从软件设计和架构的观点来看，这原则意味着类和模块必须属于一个聚合组，形成组件。组件不该简单理解为保护随机类和模块，而是这些模块必须共有架构主旨或目的。
当然这很明显，但换个角度看这件事就不能不是很明显了。类和模块被组成模块应当也一起发布。他们共有同样的版本号和同样的发布历史，包含在同样的发布文档中，对于作者和用户都很有意义。

这是个薄弱的建议：说它有某种意义只是在空中摆动双手试图很权威发声。着建议很薄弱是因为很难准确的解释把这些类和模块组成单个组件的方法，这原则本身是重要的是因为很容易发现违反的现象-因为说不通。如果违反了REP，你的用户会知道的，并对你的架构技巧没好印象。

这个原则的薄弱更需要由下面两个原则来补充强度。确实CCP和CRP强定义了这个原则，但是是从负面意义的。

## 共同封闭原则（CCP）
> 集合成模块的这些类的发生变化应当为同样的原因，并且改变次数相同，对于这些类改变不同次数为了不同原因的，分离开成不同组件。

这是单一职责原则（SRP）对组件的重新描述。类似SRP描述那样，一个类不该包含多个使它变化的原因，所以共同封闭原则（CCP）描述一个组件不该包含多个使它变化的原因。
对大多数应用，可维护性比可重用性更加重要。如果应用里的代码要变，我们希望都在同一个组件变化，而不是分散到多个组件里。如果这些变化仅限于一个单一组件，我们只要重新部署这一个组件。其他不依赖这个变化组件的也不需要重新验证和重新部署。
CCP建议我们将所有类里可能由于相同原因变化的都集合到同一个地方。如果两个雷时关联紧密，无论是物理上还是概念上，总是一起变化，那么他们应当属于同一个组件。这个办法最小化相关的发布，重新验证，重新部署软件的工作量。
这个原则和开闭原则（OCP）关系密切。确实，CCP所指的“封闭”和OCP里的很像。OCP描述类应当对修改是关闭的对扩展是开放的。因为百分百的封闭不现实，封闭应该有点取舍。我们设计类时，这些类对我们期待或经验上最相同的变化种类是封闭的。
CCP强调了集合到同个组件的这些类对同样类型的变化是封闭的。因此，当需求的变化来了，这变化很大程度上把变化的组件的数量降到最低。
### 和单一职责原则（SRP）的相似性
之前描述，CCP是SRP的组件形式描述。SRP告诉我们分离为不同原因改变的方法到不同的类。CCP告诉我们分离为不同原因改变的类到不同的组件。两个原则可描述为：
> 集合成的这些东西的发生变化应当为同样的原因，并且改变次数相同，对于这些东西改变不同次数为了不同原因的，分离被开成。





