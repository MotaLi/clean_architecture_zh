# 第十七章 边界：画线

![](/assets/17/c17.png)

软件架构是绘制线的艺术，这些线我称为边界。这些边界将软件元素彼此分开，并限制一方对其他方面的了解。其中一些线条在整个项目中很早就被提取出来了——甚至在没有写代码之前。其他的线很晚才画出。那些初期就画出的线是为了尽可能长时间地推迟决定，并且使这些决定不会污染核心业务逻辑。

回想一下，架构师的目标是最大限度地减少构建和维护所需系统所需的人力资源。这是什么样的人力（people-power）呢？耦合——特别是耦合到过早的决定。

哪种决策是不成熟的？与系统的业务需求（用例）无关的决策。这些包括关于框架，数据库，Web服务器，实用程序库，依赖注入等的决定。一个好的系统架构就是像这样的决策是辅助的和可延迟的。一个好的系统架构不依赖于这些决定。一个好的系统架构允许在最后可能的时刻做出这些决定，而不会产生很大影响。

## 一组悲伤的故事

这是关于P公司悲惨的故事，这是一个过早做出决定的警示。在20世纪80年代，P公司的创始人写了一个简单的单片桌面应用程序。他们获得了巨大的成功，并在20世纪90年代将产品发展成为流行和成功的桌面GUI应用程序。

但是，在20世纪90年代后期，网络成了一股力量。突然之间，每个人都必须有一个网络解决方案，P公司也不例外。P的客户在网上大肆宣传该产品的一个版本。为了满足这个需求，公司聘请了二十几位Java程序员，并着手开展一个项目，使他们的产品网络化。

Java程序员在他们头脑中已经想好了服务器群[^1]，所以他们采用了一个丰富的三层“架构”，他们可以这样分配服务器群。将有用于GUI的服务器，用于中间件的服务器以及用于数据库的服务器。

程序员很早就决定所有域对象都有三个实例：一个在GUI层，一个在中间件层，一个在数据库层。由于这些实例存在于不同的机器上，因此建立了一个丰富的处理器间和层间通信系统。层之间的方法调用被转换为对象，序列化，并通过线路编组。

现在想象一下，如何实现一个简单的功能，如添加一个新的字段到现有的记录。这个字段必须被添加到所有三层的类中，以及几个层间的信息中。由于数据传送是双向的，需要设计四个消息协议。[^2].每个协议都有一个发送和接收端，所以需要八个协议处理程序。必须构建三个可执行文件，每个包含三个更新的业务对象，四个新消息和八个新的处理程序。

考虑那些可执行文件为了实现最简单的功能而必须做的事情。想想所有的对象实例化，所有的序列化，所有的编组和解封装，所有的消息构建和解析，所有的套接字通信，超时管理器，重试场景以及所有其他你必须做的事情，最后完成一件简单的事情。

当然，在开发过程中，程序员没有服务器群。事实上，他们只是在一台机器上运行三个不同进程的全部三个可执行文件。他们这样开发了好几年。但他们确信他们的架构是正确的。所以即使它们在一台机器上执行，它们仍然继续所有的对象实例化，所有的序列化，所有的编组和解组，所有的消息构建和解析，所有的套接字通信，以及所有额外的东西在一台机器。

讽刺的是，P公司从来没有出售过需要服务器群的系统。他们曾经部署的每个系统都是一台服务器。在这个单一的服务器中，所有三个可执行文件都继续了所有的对象实例化，所有的序列化，所有的编组和解组，所有的消息构建和解析，所有的套接字通信以及所有额外的东西，从来不存在的服务器群，永远不会。

悲剧在于，架构师通过提前做出决定，大大增加了开发的付出。

P公司的故事不是个例。我在很多地方见过很多次。事实上，P公司这是这些地方的缩影。

但是还有比P公司更糟的。

考虑一下公司车辆管理的当地企业W公司。他们最近聘请了一名“架构师”来控制（control）他们的抹布标签软件。而且，让我告诉你，control是这个人的中间名。他很快意识到，这个小小的操作所需要的是一个全面的，企业规模的（enterprise-scale），面向服务的“架构”（service-oriented “ARCHITECTURE”）。他创建了一个业务中所有不同“对象”的巨大领域模型，设计了一套服务来管理这些领域的对象，并把所有的开发人员送去”地狱“的路上。举一个简单的例子，假设你想把联系人的姓名，地址和电话号码添加到销售记录中。你必须访问`ServiceRegistry`请求`ContactService`的服务ID。然后你必须发送一个`CreateContact`消息到`ContactService`。当然，这个消息有几十个字段，都必须有有效的数据——程序员无法访问的数据，因为程序员都是名字，地址和电话号码。[^3]伪造数据后，程序员必须将新创建的联系人的ID卡入销售记录，并将`UpdateContact`消息发送给`SaleRecordService`。

当然，无论测试任何东西你都必须逐一启动所有必要的服务，启动消息总线和BPel服务器等等，然后，随着这些消息从服务到服务间的传输，出现了传输延迟，并在一个又一个队列中等待。

然后，如果你想添加一个新功能，那么，你可以想像，所有组件的耦合，庞大的WSDL数量都需要改变，还得重新部署......

通过比较，地狱变得似乎是一个不错的地方。

围绕服务构建的软件系统没有任何内在的错误。W公司的错误是过早地采用和执行了一套承诺SoA的工具——也就是说，过早地采用了大量的领域对象服务。这些错误的代价是纯粹的个人时间，人们成群结队地冲进SoA漩涡。

我可以继续描述一个又一个的架构失败的例子。但是让我们来讨论一下架构成功的例子。

## 匹配度

## 你画哪条线，什么时候画

## 输入和输出是什么？

## 插件架构

## 小结


[^1]: The Java guys had dreams of server farms dancing in their heads.

[^2]: 译注：数据传输是双向的，如A和B通信，A发送给B，B接收后有返回回给A，这是一个过程，包含了四种消息协议。

[^3]: data to which the programmer had no access, since all the programmer had was a name, address, and phone number.

